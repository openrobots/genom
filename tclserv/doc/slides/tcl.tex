%%%
%%% Copyright (C) 2001-2009 CNRS-LAAS
%%%
\documentclass[a4paper,landscape,smooth]{show}
\usepackage{depend}
\usepackage[dpi=100,resample]{docfig}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{pp4/pause}

\context{\vfill}
\title{{\Huge T}ool {\Huge C}ommand {\Huge L}anguage}
\author{Matthieu Herrb, Anthony Mallet\\
 based on E.J. Friedman-Hill}
\date{november 2009}

\newcommand{\tclex}[2]{\texttt{#1}\\$\rightarrow$ \texttt{#2}}

\begin{document}
\maketitle
\small

% =======================================================================

\begin{part}{Introduction}{}
   \vfill
   {\bf Motivations~:} big programs always need at least 2 programing languages

   \begin{bitemize}{color@bulle}
      \item a compiled language, efficient for the algorithms (C, C++, JAVA),

      \item an interpreted language, used as glue to ``pilot''
	    and personalize the application {\bf $\rightarrow$ TCL}.
   \end{bitemize}

   \vfill
   {\bf TCL = Tool Command Language}
   \begin{bitemize}{color@bulle}
      \item Initially developped for UNIX at Berkeley University
	    by Dr. John Ousterhout (1988),
      \item Now maintained by ActiveState,

      \item open-source licence: TCL can be freely modified and
integrated, even in commercial applications.

   \end{bitemize}

   \vfill
   {\bf Prononciation~:} [tisil] (sometimes [tickle])

   \vfill
\end{part}

% -----------------------------------------------------------------------

\begin{tslide}{Tcl and LAAS softwares}
   \vfill
   \begin{bitemize}{color@bulle}
      \item \textbf{TclServ:} interface to control GenoM modules.
      \item \textbf{GDHE:} 3D visualisation (OpenGL) of robotics experiments.
      \item \textbf{Grh2:} 2D graphical environment.
      \item \textbf{Jafar:} Perception algorithms integration.
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{ Tcl language}
   \vfill
   \begin{bitemize}{color@bulle}
      \item {\bf Interpreted} command language (but compiled on line).
      \item {\bf Multiplatform}.
      \item Can be easily {\bf extended} or {\bf included} in an application (C, C++, ...).
      \item Syntax inspired from SHELL, C and LISP.
      \item {\bf Variables}  can be local, global or with a controlled scope.
      \item {\bf Dynamic (re)definition} of all the commands.
   \end{bitemize}

   \vfill
   {\bf Extensions}
   \begin{bitemize}{color@bulle}
      \item Object oriented programmation
      \item Compilers
      \item Independant execution --- without interpretor
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Tcl Language}
   \vfill
   \begin{bitemize}{color@bulle}

      \item simple syntax (similar to lisp, shell, C)
	 \begin{quote}
	    \tclex{set a 47}{47}
	 \end{quote}

      \item Substitutions:
        \begin{quote}
	   \tclex{set b \$a}{47}\\
	   \tclex{set b [expr \$a + 10]}{57}
        \end{quote}

      \item Protection:
        \begin{quote}
	  \tclex{set b "{}a equal \$a"}{a equal 47}\\
	  \tclex{set b \{[expr \$a + 10]\}}{[expr \$a + 10]}
        \end{quote}
      \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Tcl Language}
   \vfill
   {\bf Numerous built-in functions:}
   \begin{bitemize}{color@bulle}

      \item variables, associative arrays, lists,
      \item C like expressions,
      \item conditions, loops:
	 \begin{quote}
	    \begin{verbatim}
if "$x < 3" {
    puts "x is too small"
}
	    \end{verbatim} %$
	 \end{quote}
      \item access to files, processes, sockets (network).
      \item procedures,
	 \begin{quote}
	    \begin{verbatim}
proc fac x {
  if {$x <= 1} {return 1}
  expr $x*[fac [expr $x-1]]
}
	     \end{verbatim} %$
	    \vspace{2ex}
	    \tclex{fac 4}{24}
	 \end{quote}

   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Data representation}
   \vfill
   Only one data type: a string ended with
   \verb|\0|.
   \begin{bitemize}{color@bulle}
      \item on line conversion if necessary,
      \item program and data can be exchanged
	 \begin{quote}
	    \begin{verbatim}
	       set cmd "exec xemacs"
	       ...
	       eval $cmd
	    \end{verbatim} %$
	 \end{quote}
   \end{bitemize}

   Since Tcl 8.3: another type of data: binary data (example: images). 
   \vfill
\end{tslide}


% =======================================================================

\begin{part}{Tcl}{Syntax}
   \vfill
   \begin{bitemize}{color@bulle}
      \item \texttt{cmd arg arg...} \\
	 A Tcl command is made of words separated by
	 spaces. The first word is the name of the command and the following
	ones are the arguments. 

      \item \texttt{\$foo} \\ 
	 An identifier precedeed by a dollar is replaced by the corresponding
value of the variable.

      \item \texttt{[clock seconds]} \\
	 A command between square brackets is executed and replaced by the
result of the execution.

      \item \texttt{"blue bird"} \\
         The double-quotes group several words in one.
         Dollars and square brackets inside are interpreted normally.

      \item \texttt{\{blue bird\}} \\
	 Braces group several words in one. No interpretation of special
	 caracters. 

      \item \verb|\| \\
	 introduces special characters  (\verb|\n|) and annhilates the
interpretation of the dollar.

   \end{bitemize}

   \begin{center}
 {\bf No other gramar !}
   \end{center}

   \vfill
\end{part}

% -----------------------------------------------------------------------

\begin{tslide}{Grouping and substitution}
   \vfill
   The TCL syntaxic analyser works in 3 recursive steps:
   \begin{enumerate}
      \item \textbf{arguments grouping} based on the spaces between
	 the words and the groupings with the quotes and braces.

	 The end of a command is indicated by a newline or a semi-column.

      \item \textbf{substitutions} of the variables value and of the 
	 commands results between brackets.

      \item \textbf{commands execution} using the first word of each
command as index in the array of the known procedures (builtin or
added by the user in C or TCL).
   \end{enumerate}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Tcl Expressions: \texttt{expr}}
   \vfill
   \begin{bitemize}{color@bulle}
      \item C like (int and doubles)
      \item commands and variables substitution \emph{within}
	    the expressions
      \item Evaluated by \texttt{expr}, \texttt{if}, \texttt{while},
	    \texttt{for}.
   \end{bitemize}
   \vfill
   \begin{quote}
      \tclex{set b 5}{5}\\
      \tclex{expr (\$b*4) - 3}{17}\\
      \tclex{expr \$b <= 2}{0}\\
      \tclex{expr 6 * cos(2*\$b)}{-5.03443}\\
      \tclex{expr \{\$b * [fac 4]\}}{120}
   \end{quote}
   \vfill
   When are the substitutions done in the following sequence ?
   \begin{verbatim}
      set b \$a
      set a 4
      expr $b * 2
   \end{verbatim} %$
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Commented Example}
   \vfill
   \begin{quote}
      \begin{verbatim}
	 set i 0
	 while {$i < 10} {
	    puts "square $i = [expr $i*$i]"
	    incr i
	 }
      \end{verbatim}
   \end{quote}
   \vfill
   \begin{bitemize}{color@bulle}
      \item 2 commands at 1st level: \texttt{set} and \texttt{while}
      \item 2 arguments for \texttt{while}: condition and body
      \item be careful at the space between \texttt{\}} and \texttt{\{}
      \item automatic evaluation with \texttt{while} of the condition
	 $\rightarrow$ no \texttt{expr} in this case.
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Tcl arrays}
   \vfill
   Tcl arrays are \emph{associative}: the indices are strings.
   \begin{quote}
      \tclex{set x(fred) 44}{44}\\
      \tclex{set x(2) [expr \$x(fred) + 6]}{50}\\
      \tclex{array names x}{fred 2}
   \end{quote}

   \vfill
   One can simulate arrays with several dimensions:
   \begin{quote}
      \tclex{set a(1,1) 10}{10}\\
      \tclex{set a(1,2) 11}{11}\\
      \tclex{array names a}{1,1 1,2}
   \end{quote}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{String operators}
   \vfill
   Some operators work with strings:
   \begin{quote}
      \tclex{set a Bill}{Bill}\\
      \tclex{expr \{\$a < "Anne"\}}{0} 
   \end{quote}
   \vfill
   \begin{bitemize}{color@bulle}
      \item \verb|<|, \verb|>|, \verb|<=|, \verb|>=|, \verb|==| and \verb|!=|
	 work with strings but:
      \item Be careful with strings that look like numbers.
      \item One can use the function \texttt{string compare}.
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Lists}
   \vfill
   \begin{bitemize}{color@bulle}
      \item Zero or several  elements separated by spaces:
	 \begin{quote}
	    \begin{verbatim}
	       red green blue
	    \end{verbatim}
	 \end{quote}

      \item Brackets and backslashs to group:
	 \begin{quote}
	    \begin{verbatim}
	       one\ word two three
	    \end{verbatim}
	 \end{quote}

      \item Commands on lists: \texttt{concat lindex llength lsearch
	 foreach linsert lrange lsort lappend list lreplace}

      \item The indexes start at 0. \texttt{end} represents the last element.
   \end{bitemize}
   \vfill
   \textbf{Examples:}
   \begin{quote}
      \tclex{lindex "a b \{c d e\} f" 2}{c d e}\\
      \tclex{lsort \{red green blue\}}{blue green red}
   \end{quote}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Lists and commands}
   \vfill
   \begin{bitemize}{color@bulle}
      \item a command \emph{is} a list
      \item \texttt{eval} allows to evaluate a list as a command
      \item to create a command to be evaluated, use the command
	    \texttt{list}
   \end{bitemize}
   \vfill
   \begin{quote}
   \begin{verbatim}
      button .b -text Reset -command {set x $initValue}
   \end{verbatim} %$
   \emph{initValue is read when the button is used}
   \begin{verbatim}
      ... -command "set x $initValue"
   \end{verbatim} %$
   \emph{Error if initValue equal ``New York'' (2 words $\rightarrow$ set
	 x New York)}
   \begin{verbatim}
      ... -command [list set x $initValue]
   \end{verbatim} %$
   \emph{Always correct.}
   \end{quote}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Strings manipulation}
   \vfill
   \begin{bitemize}{color@bulle}
      \item Commands to manipulate strings:
	 \texttt{regexp format split string regsub scan join}
      \item sub-commands of \texttt{string}:
	 \texttt{compare first last index length match range toupper tolower
	 trim trimleft trimright}
      \item all indexes start at 0, \texttt{end} is the last character.
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{"globbing" Globalisation}
   \vfill
   Expansion of special characters in file names like in shell:
   \begin{bitemize}{color@bulle}
      \item \verb|*| any sequence of characters
      \item \verb|?| any character
      \item \verb|[|\emph{list}\verb|]| one character in \emph{list}
      \item \verb|\|\emph{c} matches \emph{c} even if \emph{c} is \verb|*|,
	 \verb|?|, \verb|[|, etc. 
   \end{bitemize}
   \vfill
   The command \texttt{glob} expands a pattern according to local files.
   \begin{quote}
   \begin{verbatim}
foreach f [glob *.exe] {
   puts "$f is a program"
}
   \end{verbatim} %$
   \end{quote}
   \vfill
   \begin{center}
      {\bf Do not mix-up with regular expressions}
   \end{center}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Regular expressions}
   \vfill
   Powerful pattern description language. Similar to \texttt{sed}.\\

   \vfill
   \begin{tabular}{ll}
      \verb|.| & any character \\
      \verb|^| & start of a string \\
      \verb|$| & end of a string \\ %$ 
      \verb|\|\emph{x} & removes the signification of \emph{x} \\
      \verb|[|\emph{list}\verb|]| & a character in \emph{list} \\
      \verb|(|\emph{regexp}\verb|)| & regular expression \emph{regexp} \\
      \verb|*| & 0 or more from the previous expression \\
      \verb|+| & 1 or more from the previous expression \\
      \verb|?| & 0 or 1 occurence of the previous expression \\
      \verb:|: & indicates an alternative between 2 expressions \\
   \end{tabular}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Regulars expressions: examples}
   \vfill
   \begin{bitemize}{color@bulle}
      \item \verb|[A-Za-z0-9_]+|: valid Tcl identifiers
      \item \verb:T(cl|k):: Tcl or Tk
      \item the \texttt{regexp} command: \\
	\tclex{regexp T(cl|k) "I speak about Tk" w t}{1}\\
	\texttt{w} equal ``Tk'' and \texttt{t} equal ``k''. 
      \item the command \texttt{regsub}: \\
	\tclex{regsub -nocase perl "I love Perl" Tcl mantra}{1}\\
	\texttt{mantra} equal ``I love Tcl''
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Commands \texttt{format} and \texttt{scan}}
   \vfill
   \begin{bitemize}{color@bulle}
      \item \texttt{format} allows to format strings like in C:\\
	 \tclex{format "I know \%d Tcl commands" [llength [info commands]]}
         {I know 105 Tcl commands}\\
      \item same functionnalities as \texttt{printf()} in C.
      \item \texttt{scan} works as \texttt{scanf()}: \\
      \tclex{set x "SSN\#: 1630799140049"}{SSN\#: 1630799140049}\\
      \tclex{scan \$x "SSN\#: \%d" ssn}{1}\\
      \tclex{puts "Social security number: \$ssn"}{Social security number: 1630799140049}\\
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Control structures}
   \vfill
   \begin{bitemize}{color@bulle}
      \item Similar to C
      \item In reality, Tcl commands as others, that take scripts in argument
      \item \textbf{Example:} revert in \texttt{b} the list stored
	 in \texttt{a}\\ 
	 \begin{verbatim}
	    set b ""
	    set i [expr [llength $a] -1]
	    while {$i >= 0} {
	       lappend b [lindex $a $i]
	       incr i -1
	    }
	 \end{verbatim}
      \item Commands: \texttt{if for switch break foreach while continue
	 eval source} 
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Control structures: examples}
   \vfill
   \begin{bitemize}{color@bulle}
      \item \texttt{if} \emph{script script}
      \item \texttt{if} \emph{script script} \texttt{else} \emph{script}
      \item \texttt{for} \emph{script expr script script} \\
      \begin{verbatim}
	 for {set i 0} {$i < 10} {incr i} {
	    ...
	 }
      \end{verbatim} %$
      \item \texttt{switch} \\
	 \begin{verbatim}
	    switch -regexp $name {
	       ^pete* {incr pete_count}
	       ^(Bob|Robert)* {incr bob_count}
	       default {incr other_count}
	    }
	 \end{verbatim} %$
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{control Structures: traps}
   \vfill
   Brackets are optionnal, but beware:
   \begin{quote}
      \begin{verbatim}
	 set x 3
	 if $x>2 { ...
      \end{verbatim} %$
   \end{quote} 
   OK because  the condition is  evaluated only once

   \vfill
   \begin{quote}
      \begin{verbatim}
	 while $x>2 {...
      \end{verbatim} %$
   \end{quote} 
   Not OK because the condition is evaluated several times.
   \vfill
\end{tslide}


% -----------------------------------------------------------------------

\begin{tslide}{Procedures}
   \vfill
   \texttt{proc} defines a procedure: 

   \tclex{proc sub1 x \{expr \$x-1\}}{sub1}\\
   \tclex{sub1 3}{2}\\

   The arguments can have default values:

   \tclex{proc decr \{x \{y 1\}\} \{expr \$x-\$y\}}{decr}\\
   \tclex{decr 3}{2}\\
   \tclex{decr 3 2}{1}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Procedures and variables scope}
   \vfill
   \begin{bitemize}{color@bulle}
      \item variables scope:  global and local variables
      \begin{itemize}
	 \item the interpreter knows the names of the variables and their
scope
	 \item each procedure introduces a new name space
      \end{itemize}
   \item \texttt{global} allows to access a global variable. 
   \item \texttt{::variable} is equivalent to \texttt{global variable}. 
   \end{bitemize}
   \begin{quote}
      \begin{verbatim}
	 set x 10
	 proc deltax {d} {
	    set x [expr \$x-\$d]
	 }
      \end{verbatim}
      \tclex{deltax 1}{can't read x: no such variable}\\
      \begin{verbatim}
	 proc deltax {d} {
	    global x
	    set x [expr \$x-\$d]
	 }
      \end{verbatim}
      \tclex{deltax 1}{9}
   \end{quote}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Variables scope: upvar}
   \vfill
   \begin{bitemize}{color@bulle}
      \item \texttt{global} is an ordinary command. It can be used with
strange effects:
	 \begin{verbatim}
	    proc let {name value} {
	       global $name
	       set $name $value
	    }
	 \end{verbatim} %$

      \item \texttt{upvar} generalizes this principle:
	 \begin{verbatim}
	    proc incr {name} {
	       upvar 1 $name var
	       set var [expr $var+1]
	    }
	 \end{verbatim}

      \item levels naming:
	 \begin{itemize}
	    \item \verb|#0| global, \verb|#1| first level call, \verb|#2|
	       second, etc.
	    \item \verb|0| current, \verb|1| level of the caller, \verb|2|
	       caller of the caller, etc.
	 \end{itemize}
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Procedures: lists of arguments of variable length}
   \vfill
   \begin{quote}
      \begin{verbatim}
	 proc sum args {
	    set s 0
	    foreach i $args {
	       incr s $i
	    }
	    return $s
	 }
      \end{verbatim} %$
      \tclex{sum 1 2 3 4 5}{15}\\
      \tclex{sum}{0}
   \end{quote}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Tcl name spaces}
   \vfill
   \begin{bitemize}{color@bulle}
      \item For large software, it is necessary to  structure the
	    code $\rightarrow$ \emph{name spaces}. 
      \item Notation: \texttt{Module::variable}
      \item Hierarchical system
      \item Allows to encapsulate data. 
      \item Command \texttt{namespace}:
	 \begin{itemize}
	    \item \texttt{namespace eval} \emph{namespace} \emph{arg...}\\
	    Evaluates \emph{arg} in the indicated space. Creates the
	    namespace if it does not exists.
	    \item \texttt{namespace export} \emph{name} \\
	    Makes variables or
	    procedures  of \emph{name} accessible from outside of the space.
	 \end{itemize}
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Name spaces: example}
   \vfill
   \begin{quote}
      \begin{verbatim}
	 namespace eval Counter {
	    namespace export bump
	    variable num 0

	    proc bump {} {
	       variable num
	       incr num
	    }
	 }
      \end{verbatim}
   \end{quote}
   \vfill
   \begin{bitemize}{color@bulle}
      \item creates the space \texttt{::Counter}
      \item a visible command \texttt{::Counter::bump}
      \item the variable \texttt{\$Counter::num} contains the current
	 value. 
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Errors}
   \vfill
   \begin{bitemize}{color@bulle}
      \item an error aborts the current command and displays a
	 message \\
	 \tclex{set n 0}{0}\\
	 \tclex{foreach i \{1 2 3 4 5\} \{\\
	    set n [expr \{\$n + i*i\}]\\
	 \}}{syntax error in expression "\$n + i*i"}
      \item the global variable \texttt{errorInfo} contains the trace of
	 the stack of calls: \\
      \tclex{set errorInfo}{syntax error in expression "\$n + i*i"\\
	 while executing\\
	 "expr \{\$n + i*i\}"\\
	 invoked from within\\
	 "set n [expr \{\$n + i*i\}]..."\\
	 ("foreach" body line 2)\\
	 ...}
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Error handling}
   \vfill
   \begin{bitemize}{color@bulle}
      \item Errors interception with \texttt{catch}
      \begin{quote}
	 \tclex{catch \{set x [expr \$y + 3]\} msg}{1}\\
	 \tclex{set msg}{can't read "y": no such variable}
      \end{quote}
      \begin{itemize}
	 \item Returns 1 if \texttt{y} is not defined, or 0.
	 \item  \texttt{msg} contains the error message,
	 \item the execution is not interrupted.
      \end{itemize}

      \item \texttt{error} allows to generate errors:
	 \begin{quote}
	    \begin{verbatim}
	       error "bad argument"
	       return -code error "bad argument"
	    \end{verbatim}
	 \end{quote}
      \item the command \texttt{unknown} is called when the first
         element of a list to be evaluated is not identified as a
         command. 
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Access to files}
   \vfill
   \begin{bitemize}{color@bulle}
      \item File access commands: \texttt{open gets seek flush
	 glob close read tell cd fconfigure fblocked fileevent puts
	 source eof pwd filename}
      \item Commands use file descriptors variables to design the open files.
     \begin{quote}
	 \tclex{set f [open "myfile.txt" "w"]}{file4}\\
	 \tclex{puts \$f "Writing in the file"}{}\\
	 \tclex{close \$f}{}
      \end{quote}

      \item \texttt{gets} and \texttt{puts} work line per line. 
      \begin{verbatim}
	 set x [gets $f]
      \end{verbatim} %$
      reads a line of \texttt{\$f} in \texttt{x}. 

      \item configurable modes with \texttt{fconfigure}
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Input/output and processes}
   \vfill
   \begin{bitemize}{color@bulle}
   \item \texttt{exec} creates a new process, can use
      \texttt{\&} like for the shell:
      \begin{quote}
	 \texttt{exec emacs \&}\\
	 \texttt{eval exec "ls [glob *.c]"}
      \end{quote}

   \item \texttt{open} allows to create pipes:
      \begin{quote}
	 \begin{verbatim}
	    set f [open "|grep foo bar.tcl" "r"]
	    while {[eof $f] != 0} {
	       puts [gets $f]
	    }
	 \end{verbatim}
      \end{quote}
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Execution  context informations}
   \vfill
   \begin{bitemize}{color@bulle}
      \item arguments on the command  line: \texttt{argc} contains their
	 count, \texttt{argv} is the list of the arguments, \texttt{argv0}
         is the name of the interpreter
      \item Tcl/Tk version: \texttt{tcl\_version}, \texttt{tk\_version}
      \item informations on the machine: the array \texttt{tk\_platform}
	 with indexes \texttt{osVersion}, \texttt{machine},
	 \texttt{platform}, \texttt{os}.

      \item the command \texttt{info}:
	 \begin{itemize}
	    \item on variables: \texttt{info vars},
	    \texttt{info globals}, \texttt{info locals},
	    \texttt{info exists}

	    \item on procedures: \texttt{info procs}, \texttt{info args},
	    \texttt{info body}, \texttt{info commands}
         \end{itemize}
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Loading code in the interpreter}
   \vfill
   \begin{bitemize}{color@bulle}
      \item \texttt{source} reads a Tcl source file and interprets it
      \item \texttt{eval} evaluates its arguments
      \item \texttt{load} loads a Tcl module (a set of C functions
	 implementing new commands)
   \end{bitemize}
   \vfill
\end{tslide}

% =======================================================================

\begin{part}{Extend Tcl}{The philosophy}
   \vfill
   \begin{bitemize}{color@bulle}
      \item Why write Tcl scripts rather than C?
         \begin{itemize}
	    \item faster development
	    \item more flexible
         \end{itemize}

      \item Why write C ?
	 \begin{itemize}
	    \item Access to low level data (devices)
	    \item Execution efficiency
	    \item Need for more structuration
	 \end{itemize}

      \item Implement new Tcl commands at 2 levels:
	 \begin{itemize}
	    \item low level to provide access to base functions
	    \item high level to hide details
	 \end{itemize}

   \end{bitemize}
   \vfill
\end{part}

% -----------------------------------------------------------------------

\begin{tslide}{New C commands}
   \vfill
   With help of modules
   \begin{bitemize}{color@bulle}
      \item Initialisation function for the module \texttt{MyModule}:
      \begin{verbatim}
	 int MyModule_Init(Tcl_Inter *interp);
      \end{verbatim}

      \item Integration of the function in the interpreter\\
	 In the initialisation function of the module:
	 \begin{verbatim}
	    Tcl_CreateObjCommand(interp, "myCommand", myFunction, NULL, NULL);
	 \end{verbatim}

      \item Prototype of a C function implementing a TCL command:
	 \begin{verbatim}
    int myFunction(ClientData clientData, Tcl_Interp *interp,
                   int objc, Tcl_Obj *const objv[]);
	 \end{verbatim}

	 \begin{description}
	    \item[clientData] user data defined later on
	    \item[interp] current Tcl interpreter
	    \item[objc] number of parameters
	    \item[objv] Tcl objects array $\rightarrow$ list of the parameters
	 \end{description}
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Access to Tcl data from C}
   \vfill
   \begin{bitemize}{color@bulle}
      \item Tcl objects (\texttt{Tcl\_Obj}): Tcl data representation
         either with a string, or in binary. 
      \item creation of an Tcl object: \texttt{Tcl\_NewStringObj()},
	 \texttt{Tcl\_NewDoubleObj()}, \texttt{Tcl\_NewListObj()}, etc.
      \item conversion of Tcl object to C data:
	 \texttt{Tcl\_GetIntFromObj()}, \texttt{Tcl\_GetDoubleFromObj()},
         etc.
      \item evalutation of Tcl expression: \texttt{Tcl\_EvalObj()}
      \item result of the Tcl command: \texttt{Tcl\_SetObjResult()}
   \end{bitemize}
   \vfill
\end{tslide}

% -----------------------------------------------------------------------

\begin{tslide}{Creation of Tcl modules}
   \vfill
   \begin{bitemize}{color@bulle}
      \item compile the C file to produce a shared object:
      \begin{verbatim}
	 gcc -c -fpic -g MyModule.c
	 gcc -shared MyModule.o -o MyModule.so
      \end{verbatim}

      \item load the module in the Tcl interpreter \texttt{tclsh} or
	 \texttt{wish}:
	    \tclex{load MyModule.so}{}\\
      \item Tcl calls automatically the C function
	 \texttt{MyModule\_Init()} to initialize the module.

      \item \texttt{MyCommand} can now be called from the
	 interpreter. 
   \end{bitemize}
   \vfill
\end{tslide}

% =======================================================================

\begin{part}{}{Tcl at LAAS}
   \vfill
   \begin{bitemize}{color@bulle}
      \item Current version: 8.5 in most Linux package systems.
      \item House-made interpreters: \texttt{eltclsh} and \texttt{elwish} in
	    \texttt{http://softs.laas.fr/openrobots}
      \item Documentations:
	 \begin{itemize}
	    \item \texttt{http://www.tcl.tk}
	    \item \texttt{http://wiki.tcl.tk}
	 \end{itemize}
   \end{bitemize}
   \vfill
\end{part}

\end{document}
