TCLserv protocol
================

- All messages are plain ASCII.
- A Windows-style line break ('\r\n') ends each message.

You have two kind of interations:

- RPC-style call like "RQST [request]". In these cases, TCL serv answers 
with either "OK [rqst_id]" or "ERROR [n] [err_msg]" (where n seems to be
 ;-) the error number returned by modules or 0 for TCL serv internal 
 errors or 1 for other errors.

- messages from TCLserv (either ACK when a module acknowledge it has 
received the request or TERM when a request finishes):
  -> "[rqst_id] [cmd name] ACK [activity_id]"
  -> "[rqst_id] [cmd name] TERM [rqst_answer]"
    rqst_answer can be either "OK [result]" or an error message from 
    the module.

To initialize the communication, the client send "HELLO" to the server.
TCLserv answers "HELLO [sock_id]" on the same socket. 'sock_id' identify the 
socket during the session.

To open other sockets, you can send other HELLO's

To define where the server will send

  
List of RPC commands:
 - HELLO|BYE: initilizes/terminates a connection to the server, and answer
the socket id.
 - REPLYTO [socket_id]: allows to specify the socket for server's
answers. To use only one socket for inbound and outbound communication, 
use the socket id returned by HELLO.
 - LM|UNLM: load or unload a module in TCL serv
 - RQST [request]: send a request
 - ABORT [activity_id]: try to abort the given activity
 - KILL [module_name] abort|verbose|showtime|resume: send the corresponding
 signal to a loaded module.
 - DIE: kill tclserv

Then any valid TCL code can be send and will be executed.
It noteworthy includes:
 - "exec -- [cmd]&" to spawn a new process, including new modules
 - "cs::lsmbox" to list all H2 mailboxes present on the server
