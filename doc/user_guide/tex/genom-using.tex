%
% Copyright (c) 2001 LAAS/CNRS                        --  Wed Nov  7 2001
% All rights reserved.                                     Anthony Mallet
%
% This document is a translation of the French documentation of GenoM,
% originally written by Sara Fleury and Matthieu Herrb.
%
% Redistribution  and  use in source   and binary forms,  with or without
% modification, are permitted provided that  the following conditions are
% met:
%
%   1. Redistributions  of  source code must  retain  the above copyright
%      notice, this list of conditions and the following disclaimer.
%   2. Redistributions in binary form must  reproduce the above copyright
%      notice,  this list of  conditions and  the following disclaimer in
%      the  documentation   and/or  other  materials   provided with  the
%      distribution.
%
% THIS SOFTWARE IS PROVIDED BY THE  AUTHOR AND CONTRIBUTORS ``AS IS'' AND
% ANY  EXPRESS OR IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES   OF MERCHANTABILITY AND  FITNESS  FOR  A PARTICULAR
% PURPOSE ARE DISCLAIMED.  IN NO  EVENT SHALL THE AUTHOR OR  CONTRIBUTORS
% BE LIABLE FOR ANY DIRECT, INDIRECT,  INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING,  BUT  NOT LIMITED TO, PROCUREMENT  OF
% SUBSTITUTE  GOODS OR SERVICES;  LOSS   OF  USE,  DATA, OR PROFITS;   OR
% BUSINESS  INTERRUPTION) HOWEVER CAUSED AND  ON ANY THEORY OF LIABILITY,
% WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
% OTHERWISE) ARISING IN ANY WAY OUT OF THE  USE OF THIS SOFTWARE, EVEN IF
% ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
% $Id$
%

This  chapter  presents some means of  using  the services  provided by a
module and of addressing data in the posters.


% =======================================================================
\section{The interactive test program {\tt Test}}
\label{sec|essay}

The interactive  test program  is a client  of  a module. One can  launch
several instances of it, provided they are  given different {\em numbers}
(see chapter~\ref{cha|session}).

This program proposes a menu, which associates  a number to each command:
You just have to  enter the number corresponding  to the command you want
to execute. Pressing the  {\tt  return}  key  without giving any   number
invokes the last command.

\subsection{Sending a request}

The $N$ requests of the module are numbered from $0$ to $N-1$. If a
request has some input parameters, they must be entered interactively.

The bracketed value is a default value: simply pressing {\tt return} will
select  it.  To  interrupt the interactive  input,  type  ``{\tt .}''  (a
single   dot):   defaults  values  will   be  affected   to the remaining
parameters. Default values are initialized to $0$.  Then they contain the
last entered value.

Once    you  have  entered  the   input   data, you    must  confirm  the
execution. Type ``{\tt a}'' to abort.  For an execution request, you must
choose between  the blocking mode or the  non-blocking mode. In the first
case,  the execution  of  the interactive program  will be  kept blocking
until the final reply of the request.  In the second case, the request is
just sent and  you  will be  able to  see   its final replies   later, by
yourself (with the command $77$, see below).


\subsection{Other commands}

Six other commands are defined:

\begin{description}
\item[55: posters] {\em Display posters}. This command displays another
menu, which lets view either a whole poster or a poster's sub-structure.

\item[66: abort] {\em Interrupt an activity}. This command displays the
list of running activities, and waits for the number of the activity you
wish to interrupt. Just type enter to leave this menu.

Note: if there is no running activity, you can stop the module by
entering {\tt -99}. {\tt -66} will resume suspended tasks.

\item[77: replies] {\em Read the final replies}. You must read pending
replies from time to time to empty the mailbox.

\item[88: state] {\em Display the module state}, {\em i.e.} the control
poster.

\item[99: quit] {\em Terminate the program}. But not the module!

\item[-99: end] {\em Terminate the program AND the module}.
\end{description}


% =======================================================================
\section{The interactive tcl shell {\tt tclserv}}
\label{sec|tcl}

{\tt tclserv} is  a server which  connects to  a  list of modules on  one
side, and accepts  tcl clients on  the other side.  Clients can then send
requests to  a   set   of   modules,  using the    {\tt  tcl}   scripting
language. This  can  be done  either interactively,  or  by the  mean  of
scripts.

To be able to use  this functionality, you must  generate the module with
the  option {\tt -t}.  A separate document   is (will be?) available, and
describe the usage of this server.


% =======================================================================
\section{{\tt OpenPRS} and {\tt transGen}}
\label{sec|propice}

You must generate the module with the option {\tt -x}.
A separate document is (not yet) available.


% =======================================================================
\section{Accessing modules' posters from modules}

Two different cases must be considered.
\begin{itemize}
\item The name of the poster to be accessed is known ({\em e.g.} the
position of a mobile in the module which produces it).
\item The poster name is not known {\em a priori}, and can be dynamically
chosen.
\end{itemize}

\subsection{The poster name is known}

To be able to read such  a poster from the  codels of a module, the three
steps below must be followed:

\subsubsection{First step: ``poster\_client'' declaration}

Posters  names    must     be    declared   within    the      field {\tt
poster\_client\_from}   of each execution   task  which  will read  those
posters ({\em i.e.}  the one that runs   the codels that implement  those
functions).

For instance, the execution task named {\tt MotionTask} can be enabled to
read the poster  {\tt Mobile} from the  module {\tt demo} and  the poster
{\tt Echoes} from the module {\tt us} by stating:

\begin{center}\begin{cartouche}\small\begin{verbatim}
exec_task MotionTask {
     ...
     poster_client_from: demo::demoMobile, us::usEcho;
     ...
};
\end{verbatim}\end{cartouche}\end{center}

This declaration lets  \GenoM\ find the necessary  libraries and call the
adequate  initialization functions.


\subsubsection{Second step: reading a poster from within its clients'
codels}

From  within the  codels,   you can call  the  poster  functions   of the
libraries {\tt usPosterLib} and {\tt  demoPosterLib} (in the {\tt  auto/}
directory of  these modules).  You just  need to include  the  files {\tt
usPosterLib.h} and {\tt demoPosterLib.h} in the codels' file.

The  poster    library   provides   read   functions     (functions  {\tt
xxxPosterRead}) and display functions (functions {\tt xxxPosterShow}) for
the control and execution posters of a module.

In  the  following  example, one  first   reads   the whole poster   {\tt
demoMobile}, then only a sub-structure {\tt Ref} (see page
\pageref{typedef|demomobile} for the structure definition):

\begin{center}\begin{cartouche}\small\begin{verbatim}
   #include "demoPosterLib.h"

   DEMO_MOBILE_POSTER_STR mobile;
   double ref;

   demoMobilePosterRead(&mobile);
   demoMobileRefPosterRead(&ref);
\end{verbatim}\end{cartouche}\end{center}

These functions return a {\tt STATUS} ({\tt OK} or {\tt ERROR}). Only the
read functions have a parameter, which is the address of the structure in
which the read data will be copied.

As shown in the example, the  function name is  the concatenation of {\em
i.} the name  of  the module, {\em ii.}   the  name of the  poster  ({\tt
Cntrl} for the control poster), {\em  iii.}  the sub-structure name (when
a subpart of the poster is addressed instead of  its whole) and {\em iv.}
the suffix {\tt PosterRead} or {\tt PosterShow}.   These functions can be
found in the header {\tt demoPosterLibProto.h}.


\subsubsection{Third step: compilation}

Compilation is handled by the GNU autoconf framework. 
It's sufficient to specify in the \texttt{requires} list of the new
module, the list of modules names it is reading posters from.  

The \texttt{configure} script will check that the necessary libraries
are present in your openrobots directory and generate the appropriate
options in the generated Makefiles.
  


\subsection{The poster name is not known}

If the name of the  poster to read is unknown  ({\em e.g.} if it will  be
set by a user) you  cannot use its  library. You must use basic functions
of the generic {\tt posterLib} library instead.

When, at run time,  you will get the  name of the  poster, you must first
find  its id  number,  which   is done  thanks   to the   functions  {\tt
posterFind}, as shown in the example below:

\begin{center}\begin{cartouche}\small\begin{verbatim}
   static POSTER_ID distantPosterId;
   char *name;
   ...
   if (posterFind(name, &distantPosterId) == ERROR) {
      *report = errnoGet();
   }
   ...
\end{verbatim}\end{cartouche}\end{center}

We have  already seen how to write  into posters. The read function works
in the same way:

The   {\tt  posterRead} function   has the  same    prototype as the {\tt
posterWrite} function:

\bigbreak
{\tt int posterRead(POSTER\_ID posterId, int offset, char *buf, int nbytes)}
\bigbreak

{\tt  posterId} is  the poster id   (returned by {\tt posterFind}),  {\tt
offset} is the offset  in bytes from  the beginning of the structure  and
{\tt  nBytes} is the number  of bytes to read.   The function returns the
number of bytes actually read (normally {\tt nBytes}).

As for {\tt posterWrite},  it is also possible to  use the address of the
poster and   write  directly into  it,  thanks  to  the {\tt  posterAddr}
function. Such accesses must be protected with a pair of {\tt posterTake}
and {\tt posterGive} ({\tt posterTake} must be  called with the flag {\tt
POSTER\_READ} instead of {\tt POSTER\_WRITE}).

\begin{center}\begin{cartouche}\small\begin{verbatim}
    double speed;

    posterTake(posterId, POSTER_READ);
    speed = addrPosterMotion->state.speed;
    posterGive(posterId);
\end{verbatim}\end{cartouche}\end{center}



\section{Accessing modules services from another process}

\subsection{The library {\tt posterLib}}

The library {\tt  demoPosterLib} provides an initialization function {\tt
demoPosterInit} and a set of  read functions (ending with {\tt PosterRead})
and display  functions (ending in {\tt  PosterShow}) for the  control and
execution posters of modules.

\subsection{The library {\tt msgLib}}

Before you can use this library, you have to create a mailbox in order to
receive the replies  of remote servers. This is   done with the  function
{\tt csMboxInit}.

Then, you  must  initialize   connections  for individual    clients: for
instance {\tt demoClientInit} in the libray {\tt demoMsgLib}.

Before you  quit, you must  free this connection with {\tt demoClientEnd}
and close the mailbox with {\tt csMboxEnd}.


\subsection{Sending requests and receiving replies}

You   can send requests  through the  functions  of the two
libraries  {\tt usMsgLib}   and {\tt  demoMsgLib}  (in  the case of   our
example). To do so, you need to include the  headers {\tt usMsgLib.h} and
{\tt demoMsgLib.h}.

The library {\tt demoMsgLib}  defines  several functions whose  names are
concatenation of: {\em i.} the name of the module, {\em  ii.} the name of
a request ({\tt  Abort} for the interrupt request),  {\em iii.} a  suffix
showing its purpose. Four suffixes are available:


\begin{center}\small\begin{tabularx}{\linewidth}{|l|X|}
\hline
suffix & function \\
\hline
\tt RqstSend & send a request (non blocking) \\

\tt ReplyRcv & receive a reply (final or intermediate)  (blocking or not)\\

\tt RqstAndRcv & send a request {\em and} receive the {\em final reply}
(blocking) \\

\tt RqstAndAck & send a request {\em and} receive the {\em intermediate reply}
(blocking) \\
\hline
\end{tabularx}\end{center}

For a  control request, you  can use  the function  {\tt RqstAndRcv} even
though it is blocking: indeed, control requests are meant to execute in a
very short time, so that the final reply should quickly occur.

However, for  an  execution request it   is strongly advised   to use the
function {\tt  RqstAndAck}, which waits only  for the  intermediate reply
(acknowledgment of the reception of the request).  In general, you cannot
block your module until the completion of the  remote request.  The final
reply will be  read with the  non-blocking function {\tt ReplyRcv}, which
you will have to call until reception of the reply.

Consider this example:

\begin{itemize}
\item To send the control request {\tt SetSpeed} to  the {\tt demo}
module, you can use the function {\tt demoSetSpeedRqstAndRcv}.

\item To send the execution request {\tt Monitor}, you can use:
   \begin{itemize}
      \item the function {\tt demoMonitorRqstAndAck} and then
      \item the function {\tt demoMonitorReplyRcv} in non-blocking mode,
until the reply comes. (if there is nothing else to do, the {\tt SLEEP}
state is particularly well suited).
   \end{itemize}
\end{itemize}

The prototypes  of  these  functions  are defined   in the  header   {\tt
auto/demoMsgLibProto.h}. Generic functions  (as for posters) also exists,
and are documented in the sections below).

\subsection{An example}

We  present here a few  examples, which involve  a task {\tt pilo} that
must send  the {\tt  SetSpeed} and   {\tt MoveDistance}  requests  to the
module {\tt demo}. 

\subsubsection{Sending a control request: {\tt RqstAndRcv}}

The functions {\tt RqstAndRcv} can have 2, 3 or 4 arguments, depending on
the input and output declarations of the request:

\begin{center}\begin{cartouche}\small\begin{verbatim}
  int ...RqstAndRcv(CLIENT_ID clientId,
                    [STR_IN *in,] [STR_OUT *out,] int *report);
\end{verbatim}\end{cartouche}\end{center}

\begin{itemize}
\item The first argument is the client number. 

\item The second and third arguments (between square brackets) are
optional, and defined only if the request defines an input or an output
parameter.

\item The last argument is the report, returned by the request.
\end{itemize}

This function returns {\tt FINAL\_REPLY\_OK}  if everything went well, or
{\tt ERROR} if not.

\bigbreak

The following example sends the {\tt SetSpeed} request:

\begin{center}\begin{cartouche}\small\begin{verbatim}
   if (demoSetSpeedRqstAndRcv(PILO_CMDTASK_DEMO_CLIENT_ID, 
                              speed, report) != FINAL_REPLY_OK) {
      /* FAIL */
   }
\end{verbatim}\end{cartouche}\end{center}


\subsubsection{Sending an execution request: {\tt RqstAndAck}}

\begin{center}\begin{cartouche}\small\begin{verbatim}
  int ...RqstAndAck(CLIENT_ID clientId,
                    int *rqstId, int replyTimeOut,
                    [STR_IN *in,] [STR_OUT *out],
                    int *activity, int *report);
\end{verbatim}\end{cartouche}\end{center}

In comparison with the {\tt ...RqstAndRcv} functions, the {\tt
RqstAndAck} functions have three more arguments:

\begin{itemize}
\item {\tt rqstId} is filled with the request id. This id will let you
read the reply later.

\item {\tt replyTimeOut} is the time (in ticks) for which you want to
wait for the final reply. The value $0$ means ``wait forever''. 

\item {\tt activity} is the activity number. This number will let you get
information on it (state) or abort it.
\end{itemize}

Note: if    the execution is  very   fast, you can   get the  final reply
immediately. This is why this function also has the {\tt out} parameter.

This function returns {\tt   WAITING\_FINAL\_REPLY} if the   intermediate
reply has been received, or {\tt FINAL\_REPLY\_OK} if the final reply has
already been received. {\tt ERROR} is returned in case of a problem.

\bigbreak

The following example shows the sending of the {\tt Monitor} request:

\begin{center}\begin{cartouche}\small\begin{verbatim}
/* Global variables */
static int piloDemoMonitoRqstId = -1;     /* Number of the request */
static int demoMonitorActivity;           /* Number of the activity */
static double piloDemoMonitorOut;         /* Output parameter */

   switch (demoMonitorRqstAndAck(PILO_CMDTASK_DEMO_CLIENT_ID, 
                                  &demoMonitorRqstId,  0,
                                  *posMon,  &piloDemoMonitorOut, 
                                  &demoMonitorActivity,  report)) {
      case WAITING_FINAL_REPLY:
         /* SLEEP */
      case FINAL_REPLY_OK:
         piloDemoMonitorRqstId = -1;
	 /* DONE */
      default:
         /* ZOMBIE */
  }  /* switch */
\end{verbatim}\end{cartouche}\end{center}


\subsubsection{Receiving replies: {\tt ReplyRcv}}

\begin{center}\begin{cartouche}\small\begin{verbatim}
  int ...ReplyRcv(CLIENT\_ID clientId,
                  int rqstId, int block,
                  [OUT *out], int *activity, int *bilan);
\end{verbatim}\end{cartouche}\end{center}

This function takes two new arguments:
\begin{itemize}
\item {\tt rqstId}, which is the identification number returned when the
request was sent,

\item {\tt block}, which tells if we want to block until the
reply arrives or not.
\end{itemize}

The  following  example shows the  reception   of the  reply of  the {\tt
Monitor}  request.  We   use the static
variables defined in the previous example.


\begin{center}\begin{cartouche}\small\begin{verbatim}
   switch (demoMonitorReplyRcv(PILO_CMDTASK_DEMO_CLIENT_ID, 
                             demoMonitorRqstId, NO_BLOCK,
                             &piloDemoMonitorOut, &demoMonitorActivity, 
                             &report)) {
      case WAITING_FINAL_REPLY:
	/* SLEEP */
      case FINAL_REPLY_OK:
         piloDemoMonitorRqstId = -1;
	/* DONE */
      default:
         /* ZOMBIE */
  }  /* switch */
\end{verbatim}\end{cartouche}\end{center}


