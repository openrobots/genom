
/* 
 * Copyright (c) 1998-2012 LAAS/CNRS
 * Sara Fleury - Wed Dec 16 1998
 * All rights reserved.
 *
 * Redistribution and use  in source  and binary  forms,  with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice,  this list of  conditions and the following disclaimer in
 *      the  documentation  and/or  other   materials provided  with  the
 *      distribution.
 *
 * THIS  SOFTWARE IS PROVIDED BY  THE  COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND  ANY  EXPRESS OR IMPLIED  WARRANTIES,  INCLUDING,  BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR  PURPOSE ARE DISCLAIMED. IN  NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR      CONTRIBUTORS  BE LIABLE FOR   ANY    DIRECT, INDIRECT,
 * INCIDENTAL,  SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE   OF THIS SOFTWARE, EVEN   IF ADVISED OF   THE POSSIBILITY OF SUCH
 * DAMAGE.
 */
#include "genom-config.h"

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdarg.h>
#include <string.h>
#include "genom.h"
#include "parser.tab.h"
#include "openprsGen.h"

static int declareRequests(FILE *out, int genTclservClient);
static void declareMainAndAtoms(FILE *out, int genTclservClient);
static void declarePosters(FILE *out);

static void declareReportAtoms(FILE *out);
static void declareEnumAtoms(FILE *out);
static int id_member(ID_LIST *m, ID_LIST *l);

static int declareCStruct(FILE *out, DCL_NOM_STR *dcl, int level)
{
     DCL_NOM_LIST *dcl_members=NULL, *l_dcl;
     int i;
     int elt, nElts=1;

     /* Nouvel element */
     if (level == 1) {
	  if (dcl->type->members)
	       fprintf(out, "declare function %s\n",  dcl->type->name);
	  else
	       fprintf(out, "declare function %s\n",  getOpenprsTYPE(dcl->type));
     } else
	       fprintf(out, "declare function %s\n",  dcl->name);

     /* A-t-il des membres ? */
     if (dcl->type != NULL)
	  dcl_members = dcl->type->members;
     
     if (dcl_members == NULL || dcl->type->type == ENUM) {
	  return 0;
     }
  
     level++;

     /* On parcours chaque element (1 seul si pas un tableau) */
     nElts = 1;
     for (i=0; i<dcl->ndimensions; i++) nElts *= (dcl->dimensions)[i];
     for (elt=0; elt<nElts; elt++) {

	  /* Appel recursif pour les membres de la structure */
	  for (l_dcl=dcl_members; l_dcl!=NULL; l_dcl=l_dcl->next) {
	       if (declareCStruct(out,l_dcl->dcl_nom, level) != 0) 
		    return -1;
	  }
     }
  
     /* Fini pour cette structure: on revient a la structure precedente */
     level--;

     return 0;

}


/***
 *** Ge'ne'ration de l'interface OPENPRS du module
 *** returns 0 if OK
 ***/

int 
openprsGen(FILE *out, int genTclservClient)
{
     RQST_LIST *rl;
     RQST_STR *rqst;
     POSTER_LIST *post;

     const char *file_header_op = 
	  ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
	  ";;    Automatically generated by GenoM: do not edit by hand.     ;;\n"
	  ";;               Copyright (C) 1999-2007 LAAS/CNRS                    ;;\n"
	  ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n";


     /* ------------------------------------------------------------
      *  LES SYM
      */
     script_open(out);
  
     /* Entete */
     cat_begin(out);
     fprintf(out, "%s", file_header_op);

     /* Declaration de chaque requete */
     for (rl = requetes; rl != NULL; rl = rl->next) {
	  rqst = rl->rqst;
	  fprintf(out, "declare op_predicate %s-%s\n", module->NAME, rqst->NAME);
	  fprintf(out, "declare op_predicate %s-%s-REPORT\n", module->NAME, rqst->NAME);
	  fprintf(out, "declare op_predicate %s-%s-ASYNC\n", module->NAME, rqst->NAME);
	  fprintf(out, "declare symbol %s_%s\n", module->NAME, rqst->NAME);
	  if (rqst->input) {
	       declareCStruct(out,rqst->input->dcl_nom,1);
	  } 
	  if (rqst->output) {
	       declareCStruct(out,rqst->output->dcl_nom,1);
	  } 

     }
     fprintf(out, "declare op_predicate %s-ABORT\n", module->NAME);
     fprintf(out, "declare op_predicate %s-ABORT-REPORT\n", module->NAME);
     fprintf(out, "declare op_predicate %s-ABORT-ASYNC\n", module->NAME);
     fprintf(out, "declare symbol %s_ABORT\n", module->NAME);

     for (post = posters; post != NULL; post = post->next) {
	  DCL_NOM_STR *n;
	  STR_REF_LIST *l;

	  fprintf(out, "declare op_predicate READ-%s-%s\n", module->NAME, post->NAME);
	  fprintf(out, "declare op_predicate WRITE-%s-%s\n", module->NAME, post->NAME);
	  fprintf(out, "declare ff %s-%s 0\n", module->NAME, post->NAME);

	  for (l = post->data; l != NULL; l = l->next) {
	       char *NAME;
	       int i;
	       n = l->str_ref->dcl_nom;
	    
	       NAME = xalloc(strlen(n->name) + 1);
	       for (i = 0; n->name[i] != '\0'; 
		    NAME[i] = toupper(n->name[i]), i++);


	       fprintf(out, "declare op_predicate READ-%s-%s-%s\n", module->NAME, post->NAME, NAME);
	       fprintf(out, "declare op_predicate WRITE-%s-%s-%s\n", module->NAME, post->NAME, NAME);
	       fprintf(out, "declare ff %s-%s-%s 0\n", module->NAME, post->NAME, NAME);
	  
	       free(NAME);

	  }
     }
     cat_end(out);

  
     script_close(out, "server/openprs/%sOpenprs.sym", module->name);
  
     /* ------------------------------------------------------------
      *  LES INC
      */
     script_open(out);
  
     /* Entete */
     cat_begin(out);
     fprintf(out, "%s", file_header_op);
     fprintf(out, "include \"@MODULEDATADIR@/%sOpenprs.sym\"\n", module->name);
     fprintf(out, "load opf \"@MODULEDATADIR@/%sOpenprs.opf\"\n", module->name);
     cat_end(out);
  
     script_close(out, "server/openprs/%sOpenprs.inc.input", module->name);
  
     /* ------------------------------------------------------------
      *  LES MAKEFILES
      */
     openprsMakeGen(out);
 
     /* ------------------------------------------------------------
      *  L'ENCODAGE DES STRUCTURES (openprs -> genom)
      */
     openprsEncodeGen(out);

     /* ------------------------------------------------------------
      *  LE DECODAGE DES STRUCTURES (genom -> openprs)
      */
     openprsDecodeGen(out);

     /* ------------------------------------------------------------
      *  LES OP pour les requetes et les posters.
      */
     openprsOpGen(out);

     /* ------------------------------------------------------------
      *  DECLARATION DES REQUETES, DES POSTERS ET DES ATOMS
      */
     script_open(out);
  
     /* Entete du fichier */
     subst_begin(out, PROTO_OPENPRS_C);
     print_sed_subst(out, "module", module->name);
     print_sed_subst(out, "MODULE", module->NAME);
     subst_end(out);

     cat_begin(out);  

     /* Declaration des requetes */
     if (!declareRequests(out,genTclservClient)) {
       return -1;
     }

     /* Declaration des posters */
     declarePosters(out);

     /* Declaration des atomes (enum + reports) */
     declareMainAndAtoms(out,genTclservClient);

     /* FIN */
     cat_end(out);
     script_close(out, "server/openprs/%sRequestsOpenprs.c", module->name);

     /* ------------------------------------------------------------
      *  LES PROTOS
      */
     script_open(out);
     subst_begin(out, PROTO_OPENPRS_PROTO);
     print_sed_subst(out, "module", module->name);
     print_sed_subst(out, "MODULE", module->NAME);
     subst_end(out);
     script_close(out, "server/openprs/%sRequestsOpenprsProto.h", module->name);

    
     return 0;

} /* openprsGen */


 
/*----------------------------------------------------------------------*
                           FONCTIONS LOCALES
 *----------------------------------------------------------------------*/

static int declareRequests(FILE *out, int genTclservClient) 
{
  RQST_STR *rqst;
  char *type, *var;
  DCL_NOM_STR *dcl;
  RQST_LIST *l;

  if (genTclservClient)
       fprintf(out, 
	       "#include <tclserv_client/tclserv_client.h>\n"
	       "#include <tclservClient/%sTclservClientMsgLib.h>\n"
	       "#include <server/tclservClient/%sError.h>\n",
	       module->name, module->name);

  /* Tableau de declaration de toutes les requetes */
  fprintf(out, 
	  "\n/*----------------------------------------------------------------------*/\n"
	  "\n"
	  "/*\n"
	  " * Requests declaration\n"
	  " */\n"
	  "static void init_%s_rqst_type_table ()\n"
	  "{\n", 
	  module->name);

  /* Pour chaque requetes  */
  for (l = requetes; l != NULL; l = l->next) {
    rqst = l->rqst;
    
    /* Declaration de la requete */ 
    fprintf(out, 
	    "  init_rqst_type(\"%s_%s\", %s_%s_RQST,\n",
	    module->NAME, rqst->NAME, module->NAME, rqst->NAME);

    /* Selection de la fonction d'encode pour INPUTS (OPENPRS -> C) */
    if (rqst->input == NULL) {
	 if (genTclservClient)
	      fprintf(out, "               null_encode, 0, %sTclservClient%sRqstSend,\n", module->name, rqst->name);
	 else
	      fprintf(out, "               null_encode, 0, (FRI)0,\n");
    }
    else {
      /* Type de l'input */
      dcl = rqst->input->dcl_nom;

      /* array and string refused for now */
      if((dcl->flags & STRING) || (dcl->flags &ARRAY)) {
	printf("ERROR input %s[] of request %s: openprs does not accept array or string as request input or output parameter\n",
	       dcl->name, rqst->name);
	return 0;
      }

      /* XXXX 15/06/2007:
	 This does not work for now because the pu_encode_genom_<STRUCT> functions do not allow to manage array of <STRUCT>.
	 Wheras  pu_encode_genom_string, like others basic type pu_encode_genom_<TERM> functions allows it. 
	 Thus, relatively to the pu_encode_genom_<STRUCT>, they have a 5th parameter (the size of the array).
	 Thus pu_encode_genom_string prototype is not compatible here.
	 Solution: generalisation of all pu_encode_genom_<STRUCT> functions to 5 paramaters and array management.....
*/
      if(dcl->flags & STRING) {
	 if (genTclservClient)
	      fprintf(out, "               (Encode_Func_Proto)pu_encode_genom_string, %d, %sTclservClient%sRqstSend,\n",
		      dcl->dimensions[0], module->name, rqst->name);
	 else
	      fprintf(out, "               (Encode_Func_Proto)pu_encode_genom_string, %d, (FRI)0,\n",
		      dcl->dimensions[0]);
      }

      else {
	dcl_nom_decl(dcl, &type, &var);
	 if (genTclservClient)
	      fprintf(out, "               (Encode_Func_Proto)pu_encode_genom_%s, sizeof(%s), %sTclservClient%sRqstSend,\n",
		      nom_type1(dcl->type), nom_type(dcl->type), module->name, rqst->name);
	 else
	      fprintf(out, "               (Encode_Func_Proto)pu_encode_genom_%s, sizeof(%s), (FRI)0,\n",
		      nom_type1(dcl->type), nom_type(dcl->type));
	free(type);
	free(var);
      }
    }

    /* Selection de la fonction de decode pour OUTPUTS  (C -> OPENPRS) */
    if (rqst->output == NULL) {
	 if (genTclservClient)
	      fprintf(out, "               null_decode, 0, %sTclservClient%sReplyRcv);\n", module->name, rqst->name);
	 else
	      fprintf(out, "               null_decode, 0, (FRI)0);\n");
    }
    else {
      /* Type de l'output */
      dcl = rqst->output->dcl_nom;

      /* array and string refused for now */
      if((dcl->flags & STRING) || (dcl->flags &ARRAY)) {
	printf("ERROR output %s[] of request %s: openprs does not accept array or string as request output or output parameter\n",
	       dcl->name, rqst->name);
	return 0;
      }


      /* this does not work for now */
      if(dcl->flags & STRING) {
	   if (genTclservClient)
		fprintf(out, "               (Decode_Func_Proto)pu_decode_genom_string, %d, %sTclservClient%sReplyRcv);\n",
			dcl->dimensions[0], module->name, rqst->name);
	   else
		fprintf(out, "               (Decode_Func_Proto)pu_decode_genom_string, %d, (FRI)0);\n",
			dcl->dimensions[0]);
      }
      else {
	dcl_nom_decl(dcl, &type, &var);
	if (genTclservClient)
	     fprintf(out, "               (Decode_Func_Proto)pu_decode_genom_%s, sizeof(%s), %sTclservClient%sReplyRcv);\n",
		     nom_type1(dcl->type),  nom_type(dcl->type), module->name, rqst->name);
	else
	     fprintf(out, "               (Decode_Func_Proto)pu_decode_genom_%s, sizeof(%s), (FRI)0);\n",
		     nom_type1(dcl->type),  nom_type(dcl->type));
	free(type);
	free(var);
      }
    }

  } /* for */
  
  /* Abort request */
  if (genTclservClient)
       fprintf(out, 
	       "  init_rqst_type(\"%s_ABORT\", %s_ABORT_RQST,\n"
	       "               (Encode_Func_Proto)pu_encode_genom_int, sizeof(int), tclserv_client_abort,\n"
	       "               null_decode, 0, (FRI)0);\n",
	       module->NAME, module->NAME);
  else
       fprintf(out, 
	       "  init_rqst_type(\"%s_ABORT\", %s_ABORT_RQST,\n"
	       "               (Encode_Func_Proto)pu_encode_genom_int, sizeof(int), (FRI)0,\n"
	       "               null_decode, 0, (FRI)0);\n",
	       module->NAME, module->NAME);
  
  /* Fin de la declaration des requetes */
  fprintf(out, "}\n");
  return 1;

} /* declareRequests */


/**
 ** DECLARATION DES ATOMS (bilans + enum)
 **/

static void declareMainAndAtoms(FILE *out, int genTclservClient) 
{
  /* La fonction de declaration */
  fprintf(out, 
	  "/*\n"
	  " * This is the main function which declares everything.\n"
	  " */\n"
	  "void init_%s_module ()\n"
	  "{\n",
	  module->name);

  if (genTclservClient)
       fprintf(out, "\n     declare_oprs_module(\"%s\", \"%s_REQUEST\",%sClientInit,%sTclservClientInit,%s_error_str);",
	       module->NAME, module->NAME, module->name, module->name, module->name);
  else
       fprintf(out, "\n     declare_oprs_module(\"%s\", \"%s_REQUEST\",%sClientInit, (FRI) 0, (FRCS)0);",
	       module->NAME, module->NAME, module->name);

 
  /* Les enum */
  declareEnumAtoms(out);

  /* Les reports */
  declareReportAtoms(out);

  fprintf(out, "\n     init_%s_rqst_type_table ();\n"
	  "     init_%s_posters ();\n\n",
	  module->name, module->name);
 
  /* Termine la fonction */
  fprintf(out, "}\n\n");

}



static void declarePosters(FILE *out) 
{
  POSTER_LIST *post;
  
  /**
   ** DECLARATION DES POSTERS ...
   **/

  /* La fonction de declaration */
  fprintf(out, 
	  "/*\n"
	  " * Posters declaration\n"
	  " */\n"
	  "static void init_%s_posters ()\n"
	  "{\n    void *x;\n\n",
	  module->name);

    for (post = posters; post != NULL; post = post->next) {
	 STR_REF_STR *m;
	 DCL_NOM_STR *n;
	 char *type, *var, *type1;
	 STR_REF_LIST *l;

	 /* Type de la donnee  */
	 type1 = nom_type1(post->type);

	fprintf(out, 
		"   declare_poster_function(\"|%s%s|\",\n"
		"                 \"%s_%s\",\n"
		"                 (Decode_Func_Proto)pu_decode_genom_%s,\n"
		"                 (Encode_Func_Proto)pu_encode_genom_%s,\n"
		"                 0);\n", 
		module->name, post->name,
		module->NAME, post->NAME, 
		type1,
		type1);
	free(type1);

	for (l = post->data; l != NULL; l = l->next) {
	     char *NAME;
	     int i;
	     m = l->str_ref;
	     n = m->dcl_nom;
	     dcl_nom_decl(n, &type, &var);
	
	     NAME = xalloc(strlen(n->name) + 1);
	     for (i = 0; n->name[i] != '\0'; 
		  NAME[i] = toupper(n->name[i]), i++);

	     /* XXXXX Type de la donnee  (pas sur q'il faille faire ca) */
	     if(n->flags & STRING)
	       type1 = strdup("string");
	     else 
	       type1 = nom_type1(n->type);

	     fprintf(out, 
		     "   declare_poster_function(\"|%s%s|\",\n"
		     "                 \"%s_%s_%s\",\n"
		     "                 (Decode_Func_Proto)pu_decode_genom_%s,\n"
		     "                 (Encode_Func_Proto)pu_encode_genom_%s,\n"
		     "                 (int)&(((%s *)x)->%s) - (int)((%s *)x));\n", 
		     module->name, post->name,
		     module->NAME, post->NAME, NAME,
		     type1,
		     type1,
		     post->type->name, n->name, post->type->name);
	     free(type1);
	     free(NAME);
	}
    }
  /* Termine la fonction */
  fprintf(out, "}\n\n");

} /* declarePosters */


static void declareEnumAtoms(FILE *out)
{
  DCL_NOM_LIST *m;
  TYPE_LIST *l;
  TYPE_STR *t;

  fprintf(out,
	 "\n  /* Enums */\n");

  for (l = types; l != NULL; l = l->next) {
    t = l->type;
    if (t->type == ENUM) {
      for (m = t->members; m != NULL; m = m->next) {
	fprintf(out,
	       "  PU_DECLARE_ENUM_ATOM(%s);\n",
	       m->dcl_nom->name);
      }
    }
  }
}


static void declareReportAtoms(FILE *out)
{
  RQST_LIST *l;
  RQST_STR *r;
  ID_LIST *m, *reportList = NULL, *tmp;

  /* Construction d'une liste unique de reports */
  for (l = requetes; l != NULL; l = l->next) {
    r = l->rqst;
    for (m = r->fail_reports; m != NULL; m = m->next) {
      if (!id_member(m, reportList)) {
	tmp = (ID_LIST *)xalloc(sizeof(ID_LIST));
	tmp->name = m->name;
	tmp->next = reportList;
	reportList = tmp;
      }
    }
  }

  fprintf(out,
	 "\n  /* Reports */\n");

  /* generation liste */
  for (m = reportList; m != NULL; m = m->next) {
    fprintf(out,
	   "  PU_DECLARE_ENUM_ATOM(S_%s_%s);\n",
	   module->name, m->name);
  }
  /* Liberation liste */
  for (m = reportList; m != NULL; tmp = m->next, free(m), m = tmp);
}


static int id_member(ID_LIST *m, ID_LIST *l)
{
    for (; l != NULL; l = l->next) {
	if (!strcmp(m->name, l->name)) {
	    return(-1);
	}
    }
    return(0);
}

