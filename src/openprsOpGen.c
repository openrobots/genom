
/* 
 * Copyright (c) 1998-2003 LAAS/CNRS
 * Sara Fleury - Wed Dec 16 1998
 * All rights reserved.
 *
 * Redistribution and use  in source  and binary  forms,  with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   1. Redistributions of  source  code must retain the  above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice,  this list of  conditions and the following disclaimer in
 *      the  documentation  and/or  other   materials provided  with  the
 *      distribution.
 *
 * THIS  SOFTWARE IS PROVIDED BY  THE  COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND  ANY  EXPRESS OR IMPLIED  WARRANTIES,  INCLUDING,  BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR  PURPOSE ARE DISCLAIMED. IN  NO EVENT SHALL THE COPYRIGHT
 * HOLDERS OR      CONTRIBUTORS  BE LIABLE FOR   ANY    DIRECT, INDIRECT,
 * INCIDENTAL,  SPECIAL,  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR
 * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE   OF THIS SOFTWARE, EVEN   IF ADVISED OF   THE POSSIBILITY OF SUCH
 * DAMAGE.
 */
#include "genom-config.h"

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdarg.h>
#include <string.h>
#include "genom.h"
#include "parser.tab.h"
#include "openprsGen.h"

/* Production des OP */
static int breakUpCStruct(DCL_NOM_STR *dcl, int *level, int *numvar);
static int addOpParams (DCL_NOM_STR *dcl_nom, int *numvar);
static void  makeEnumDoc(DCL_NOM_STR *dcl_nom, char **docString);

char *opParamsString=NULL;
char *docString=NULL;


/***
 *** Ge'ne'ration de l'interface OPENPRS du module
 ***/


int 
openprsOpGen(FILE *out)
{
  RQST_LIST *l;
  RQST_STR *rqst;
  DCL_NOM_STR *dcl;
  int level=1;
  int numvar = 0;
  ID_LIST *mess;
  POSTER_LIST *post;


  const char *file_header_op = 
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n"
";;    Automatically generated by GenoM: do not edit by hand.     ;;\n"
";;               Copyright (C) 1999 LAAS/CNRS                    ;;\n"
";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n";


  /* ------------------------------------------------------------
   *  LES OP
   */
  script_open(out);
  
  /* Entete */
  cat_begin(out);
  fprintf(out, "%s", file_header_op);
  fprintf(out, "(\n");
  cat_end(out);
  
  /* Chaque requete */
  for (l = requetes; l != NULL; l = l->next) {
    rqst = l->rqst;
    subst_begin(out, PROTO_OPENPRS_RQST_OP);
    
    /* Nom du  module, requete */
    print_sed_subst(out, "module", module->name);
    print_sed_subst(out, "MODULE", module->NAME);
    print_sed_subst(out, "request", rqst->name);
    print_sed_subst(out, "REQUEST", rqst->NAME);
    
    /* INPUTS */
    if (rqst->input == NULL) {
      print_sed_subst(out, "INPUTS", "nil");
      print_sed_subst(out, "INPUTS_ARG", "");
    } 
    /* Decomposition de la structure d'input */
    else {
      dcl = rqst->input->dcl_nom;
      if (breakUpCStruct (dcl, &level, &numvar) != 0) {
	subst_end(out);
	script_close(out, "server/openprs/%sOpenprs.opf", module->name);
	return -1;
      }
      print_sed_subst(out, "INPUTS", "%s", opParamsString);
      print_sed_subst(out, "INPUTS_ARG", "%s", opParamsString);
      free(opParamsString);
      opParamsString=NULL;
    }

    /* OUTPUTS */
    if (rqst->output == NULL) {
      print_sed_subst(out, "OUTPUTS", "nil");
      print_sed_subst(out, "KEEP_OUTPUTS", ";");
    } 
    /* Decomposition de la structure d'output */
    else {
      dcl = rqst->output->dcl_nom;
      if (breakUpCStruct (dcl, &level, &numvar) != 0) {
	subst_end(out);
	script_close(out, "server/openprs/%sOpenprs.opf", module->name);
	return -1;
      }
      print_sed_subst(out, "OUTPUTS", "%s", opParamsString);
      print_sed_subst(out, "KEEP_OUTPUTS", "");
      free(opParamsString);
      opParamsString=NULL;
   }

    /* DOC : reports and enums */
    bufcat(&docString, "\nReports: ");
    for (mess = rqst->fail_reports; mess != NULL; mess = mess->next) {
      bufcat(&docString, "%s  ", mess->name);
    }
    print_sed_subst(out, "DOC", "%s", docString);
    free(docString);
    docString=NULL;


    /* Substitution termee */
    subst_end(out);

  } /* for each request */

  /* abort request */

    subst_begin(out, PROTO_OPENPRS_RQST_OP);
    
    /* Nom du  module, requete */
    print_sed_subst(out, "module", module->name);
    print_sed_subst(out, "MODULE", module->NAME);
    print_sed_subst(out, "request", "abort");
    print_sed_subst(out, "REQUEST", "ABORT");
    
    print_sed_subst(out, "INPUTS", "(INTEGER  \\$TASK-ID)");
    print_sed_subst(out, "INPUTS_ARG", "(INTEGER  \\$TASK-ID)");


    print_sed_subst(out, "OUTPUTS", "nil");
    print_sed_subst(out, "KEEP_OUTPUTS", ";");

    print_sed_subst(out, "DOC", "");
    
    /* Substitution termee */
    subst_end(out);

  for (post = posters; post != NULL; post = post->next) {
       STR_REF_STR *m;
       DCL_NOM_STR *n;
       STR_REF_LIST *l;

       subst_begin(out, PROTO_OPENPRS_PSTR_OP);

       print_sed_subst(out, "MODULE", module->NAME);
       print_sed_subst(out, "module", module->name);
       print_sed_subst(out, "poster", post->name);
       print_sed_subst(out, "POSTERU", "%s_%s", module->NAME, post->NAME);
       print_sed_subst(out, "POSTERM", "%s-%s", module->NAME, post->NAME);
       print_sed_subst(out, "ref", "");

#if 0
       dcl = post->type->name;
       if (breakUpCStruct (dcl, &level, &numvar) != 0) {
	    subst_end(out);
	    script_close(out, "server/openprs/%sOpenprs.opf", module->name);
	    return -1;
       }
	 
       print_sed_subst(out, "POST_PPC_STRUCT", "%s", opParamsString);

       free(opParamsString);
       opParamsString=NULL;
#endif
       subst_end(out);

       for (l = post->data; l != NULL; l = l->next) {
	    char *NAME;
	    int i;
	    m = l->str_ref;
	    n = m->dcl_nom;
	    
	    NAME = xalloc(strlen(n->name) + 1);
	    for (i = 0; n->name[i] != '\0'; 
		 NAME[i] = toupper(n->name[i]), i++);

	  
	    subst_begin(out, PROTO_OPENPRS_PSTR_OP);

	    print_sed_subst(out, "MODULE", module->NAME);
	    print_sed_subst(out, "module", module->name);
	    print_sed_subst(out, "poster", post->name);
	    print_sed_subst(out, "POSTERU", "%s_%s_%s", module->NAME, post->NAME, NAME);
	    print_sed_subst(out, "POSTERM", "%s-%s-%s", module->NAME, post->NAME, NAME);
	    print_sed_subst(out, "ref", " %s",  n->name);
	    free(NAME);
	 
#if 0
	    dcl = foo;
	    if (breakUpCStruct (dcl, &level, &numvar) != 0) {
		 subst_end(out);
		 script_close(out, "server/openprs/%sOpenprs.opf", module->name);
		 return -1;
	    }
	 
	    print_sed_subst(out, "POST_PPC_STRUCT", "%s", opParamsString);

	    free(opParamsString);
	    opParamsString=NULL;
#endif

	    subst_end(out);
       }
  }

  
  /* Fin OPF */
  cat_begin(out);
  fprintf(out, "\n)\n");
  cat_end(out);
  
  script_close(out, "server/openprs/%sOpenprs.opf", module->name);

  return 0;
} /* openprsGen */


/*======================================================================*/
/*                   FONCTIONS LOCALES                                  */
/*======================================================================*/

/**--------------------------------------------------------------------
 ** 
 **  breakUpCStruct: fonction recursive qui met a plat une structure dcl
 **                pour les parametres des OP
 **/
static int breakUpCStruct(DCL_NOM_STR *dcl, int *level, int *numvar) 
{
  DCL_NOM_LIST *dcl_members=NULL, *l_dcl;
  int i;
  int elt, nElts=1;


  /* Indentation */
  bufcat(&opParamsString,  "\n");
  bufcat(&opParamsString,  "     ");
  for (i=0; i<*level; i++)
    bufcat(&opParamsString,  "   ");

  /* Nouvel element */
  if (*level == 1) {
       if (dcl->type->members)
	    bufcat (&opParamsString,  "(%s ",  dcl->type->name);
       else
	    bufcat (&opParamsString,  "(%s ", getOpenprsTYPE(dcl->type));
  } else
       bufcat (&opParamsString,  "(%s ", dcl->name);

  /* A-t-il des membres ? */
  if (dcl->type != NULL)
    dcl_members = dcl->type->members;

  /* 
   * Element terminal 
   */
  if (dcl_members == NULL || dcl->type->type == ENUM) {
    if (addOpParams (dcl, numvar) != 0) 
      return -1;
    if (dcl->type->type == ENUM)
      makeEnumDoc(dcl, &docString);
    bufcat(&opParamsString,  ")");
    return 0;
  }
 
  /* 
   * Structure a decomposer 
   */
  (*level)++;

  /* On parcours chaque element (1 seul si pas un tableau) */
  nElts = 1;
  for (i=0; i<dcl->ndimensions; i++) nElts *= (dcl->dimensions)[i];
  for (elt=0; elt<nElts; elt++) {

    /* Appel recursif pour les membres de la structure */
    for (l_dcl=dcl_members; l_dcl!=NULL; l_dcl=l_dcl->next) {
      if (breakUpCStruct(l_dcl->dcl_nom, level, numvar) != 0) 
	return -1;
    }
  }
  
  /* Fini pour cette structure: on revient a la structure precedente */
  (*level)--;
  bufcat (&opParamsString,  ")\n");

  return 0;
} 

/**--------------------------------------------------------------------
 **  addOpParams - Fonction annexe a breakUpCStruct :
 **                construction de la liste des parametres
 **/

static int addOpParams (DCL_NOM_STR *dcl_nom, int *numvar)
{
  int i; 
  int ndims = dcl_nom->ndimensions;
  int *dims = dcl_nom->dimensions;
  int elt, nElts;

  /* Variable de type STRING ou tableau de STRING */
  if (dcl_nom->flags & STRING)
    ndims--;

  /* Calcul du nombre d'elements */
  for (nElts=1, i=0; i<ndims; i++) 
    nElts *= (dims)[i];

  /* On traite chaque element */
  for (elt=0; elt<nElts; elt++) {

    /* Variable de type STRING ou tableau de STRING */
    if (dcl_nom->flags & STRING) {
      bufcat(&opParamsString,  " \\$string%d-%d", 
	     dims[ndims],
	     *numvar);
    } 
    
    /* Autre variable ou tableau de variables */
    else {
      bufcat(&opParamsString, " \\$%s-%d",  
	     getOpenprsTYPE(dcl_nom->type), *numvar);
    } 

    /* Incremente le numero de l'element */
    (*numvar)++;
    
  } /* for: Adjonction de chaque element */

  return 0;
} 

static void  makeEnumDoc(DCL_NOM_STR *dcl_nom, char **docString)
{
  DCL_NOM_LIST *m;
  DCL_NOM_LIST *members;

  members = dcl_nom->type->members;

  bufcat(docString, "\nValues for %s : ", dcl_nom->name);
  for (m = members; m != NULL; m = m->next) 
    bufcat(docString, " %s", m->dcl_nom->name);
}

/**--------------------------------------------------------------------
 **  getOpenprsTYPE - 
 **/

char *getOpenprsTYPE(TYPE_STR *type)
{
  switch (type->type) {
  case CHAR:
    return("STRING");
  case SHORT:
    return("INTEGER");
  case INT:
    return ("INTEGER");
  case ENUM:
    return("ATOM");
  case FLOAT:
    return("FLOAT");
  case DOUBLE:
    return("FLOAT");
  default:
    return("TERM_COMP");
  } /* switch */
}

