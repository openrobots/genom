#!/usr/bin/env perl
#
# Kill a Genom module running under a Unix system
#
# Matthieu Herrb - Fevrier 2001
#
# $LAAS$
#----------------------------------------------------------------------
#
# Check arguments
if ($#ARGV != 0) {
  print STDERR "syntaxe: $0 <module>\n";
  exit -1;
}
$module = $ARGV[0];
# host name
$host = `uname -n`;
chop $host;
# name of the file holding the process id
$pid_file = "$ENV{'HOME'}/.$module.pid-$host";
$me = $ENV{'USER'};
# Check its existence
if ( ! -f $pid_file) {
  print STDERR "$0: the module $module doesn't seem to be running on $host\n";
  exit 1;
}
# Check the owner of the file
$uid = (stat($pid_file))[4];	# numerical uid of the file
$name = (getpwuid($uid))[0];	# get the actual user name
if ( $me ne $name ) {
  print STDERR "$0: the $module process is owned by $name (not $me)\n";
  exit -1;
}
# Read the file
open PID,"<$pid_file" || die "can't read $pid_file";
$pid = <PID>;
if (defined($pid)) {
  print "pid ".$pid;
  chop $pid;
  close PID;
  # send SIGTERM 
  kill 15, $pid;
}
# Wait a bit for the module to die cleanly
$now = time();
do {
  select(undef, undef, undef, 1.0);
} while (-f $pid_file && time() < $now + 10);

# if file still there, use SIGINT
if (-f $pid_file) {
  print("$module takes too long to die, sending SIGINT\n");
  kill 2, $pid;
  # wait
  select(undef, undef, undef, 3.0);
  
  # Remove the pid file
  if (-f $pid_file) {
    unlink("$pid_file");
  }
  # Clean up pocolib devices of the module
  system("h2 clean '*$module*'");
} else {
  print("done\n");
}
# done
exit 0;
